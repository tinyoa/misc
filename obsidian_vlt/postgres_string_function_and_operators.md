
https://www.postgresql.org/docs/current/functions-string.html


|Function/Operator<br><br>Description<br><br>Example(s)|
|---|
|`text` `\|` `text` → `text`<br><br>Concatenates the two strings.<br><br>`'Post' \| 'greSQL'` → `PostgreSQL`|
|`text` `\|` `anynonarray` → `text`<br><br>`anynonarray` `\|` `text` → `text`<br><br>Converts the non-string input to text, then concatenates the two strings. (The non-string input cannot be of an array type, because that would create ambiguity with the array `\|` operators. If you want to concatenate an array's text equivalent, cast it to `text` explicitly.)<br><br>`'Value: ' \| 42` → `Value: 42`|
|`btrim` ( _`string`_ `text` [, _`characters`_ `text` ] ) → `text`<br><br>Removes the longest string containing only characters in _`characters`_ (a space by default) from the start and end of _`string`_.<br><br>`btrim('xyxtrimyyx', 'xyz')` → `trim`|
|`text` `IS` [`NOT`] [_`form`_] `NORMALIZED` → `boolean`<br><br>Checks whether the string is in the specified Unicode normalization form. The optional _`form`_ key word specifies the form: `NFC` (the default), `NFD`, `NFKC`, or `NFKD`. This expression can only be used when the server encoding is `UTF8`. Note that checking for normalization using this expression is often faster than normalizing possibly already normalized strings.<br><br>`U&'\0061\0308bc' IS NFD NORMALIZED` → `t`|
|`bit_length` ( `text` ) → `integer`<br><br>Returns number of bits in the string (8 times the `octet_length`).<br><br>`bit_length('jose')` → `32`|
|`char_length` ( `text` ) → `integer`<br><br>`character_length` ( `text` ) → `integer`<br><br>Returns number of characters in the string.<br><br>`char_length('josé')` → `4`|
|`lower` ( `text` ) → `text`<br><br>Converts the string to all lower case, according to the rules of the database's locale.<br><br>`lower('TOM')` → `tom`|
|`lpad` ( _`string`_ `text`, _`length`_ `integer` [, _`fill`_ `text` ] ) → `text`<br><br>Extends the _`string`_ to length _`length`_ by prepending the characters _`fill`_ (a space by default). If the _`string`_ is already longer than _`length`_ then it is truncated (on the right).<br><br>`lpad('hi', 5, 'xy')` → `xyxhi`|
|`ltrim` ( _`string`_ `text` [, _`characters`_ `text` ] ) → `text`<br><br>Removes the longest string containing only characters in _`characters`_ (a space by default) from the start of _`string`_.<br><br>`ltrim('zzzytest', 'xyz')` → `test`|
|`normalize` ( `text` [, _`form`_ ] ) → `text`<br><br>Converts the string to the specified Unicode normalization form. The optional _`form`_ key word specifies the form: `NFC` (the default), `NFD`, `NFKC`, or `NFKD`. This function can only be used when the server encoding is `UTF8`.<br><br>`normalize(U&'\0061\0308bc', NFC)` → `U&'\00E4bc'`|
|`octet_length` ( `text` ) → `integer`<br><br>Returns number of bytes in the string.<br><br>`octet_length('josé')` → `5` (if server encoding is UTF8)|
|`octet_length` ( `character` ) → `integer`<br><br>Returns number of bytes in the string. Since this version of the function accepts type `character` directly, it will not strip trailing spaces.<br><br>`octet_length('abc '::character(4))` → `4`|
|`overlay` ( _`string`_ `text` `PLACING` _`newsubstring`_ `text` `FROM` _`start`_ `integer` [ `FOR` _`count`_ `integer` ] ) → `text`<br><br>Replaces the substring of _`string`_ that starts at the _`start`_'th character and extends for _`count`_ characters with _`newsubstring`_. If _`count`_ is omitted, it defaults to the length of _`newsubstring`_.<br><br>`overlay('Txxxxas' placing 'hom' from 2 for 4)` → `Thomas`|
|`position` ( _`substring`_ `text` `IN` _`string`_ `text` ) → `integer`<br><br>Returns first starting index of the specified _`substring`_ within _`string`_, or zero if it's not present.<br><br>`position('om' in 'Thomas')` → `3`|
|`rpad` ( _`string`_ `text`, _`length`_ `integer` [, _`fill`_ `text` ] ) → `text`<br><br>Extends the _`string`_ to length _`length`_ by appending the characters _`fill`_ (a space by default). If the _`string`_ is already longer than _`length`_ then it is truncated.<br><br>`rpad('hi', 5, 'xy')` → `hixyx`|
|`rtrim` ( _`string`_ `text` [, _`characters`_ `text` ] ) → `text`<br><br>Removes the longest string containing only characters in _`characters`_ (a space by default) from the end of _`string`_.<br><br>`rtrim('testxxzx', 'xyz')` → `test`|
|`substring` ( _`string`_ `text` [ `FROM` _`start`_ `integer` ] [ `FOR` _`count`_ `integer` ] ) → `text`<br><br>Extracts the substring of _`string`_ starting at the _`start`_'th character if that is specified, and stopping after _`count`_ characters if that is specified. Provide at least one of _`start`_ and _`count`_.<br><br>`substring('Thomas' from 2 for 3)` → `hom`<br><br>`substring('Thomas' from 3)` → `omas`<br><br>`substring('Thomas' for 2)` → `Th`|
|`substring` ( _`string`_ `text` `FROM` _`pattern`_ `text` ) → `text`<br><br>Extracts the first substring matching POSIX regular expression; see [Section 9.7.3](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP "9.7.3. POSIX Regular Expressions").<br><br>`substring('Thomas' from '...$')` → `mas`|
|`substring` ( _`string`_ `text` `SIMILAR` _`pattern`_ `text` `ESCAPE` _`escape`_ `text` ) → `text`<br><br>`substring` ( _`string`_ `text` `FROM` _`pattern`_ `text` `FOR` _`escape`_ `text` ) → `text`<br><br>Extracts the first substring matching SQL regular expression; see [Section 9.7.2](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-SIMILARTO-REGEXP "9.7.2. SIMILAR TO Regular Expressions"). The first form has been specified since SQL:2003; the second form was only in SQL:1999 and should be considered obsolete.<br><br>`substring('Thomas' similar '%#"o_a#"_' escape '#')` → `oma`|
|`trim` ( [ `LEADING` \| `TRAILING` \| `BOTH` ] [ _`characters`_ `text` ] `FROM` _`string`_ `text` ) → `text`<br><br>Removes the longest string containing only characters in _`characters`_ (a space by default) from the start, end, or both ends (`BOTH` is the default) of _`string`_.<br><br>`trim(both 'xyz' from 'yxTomxx')` → `Tom`|
|`trim` ( [ `LEADING` \| `TRAILING` \| `BOTH` ] [ `FROM` ] _`string`_ `text` [, _`characters`_ `text` ] ) → `text`<br><br>This is a non-standard syntax for `trim()`.<br><br>`trim(both from 'yxTomxx', 'xyz')` → `Tom`|
|`upper` ( `text` ) → `text`<br><br>Converts the string to all upper case, according to the rules of the database's locale.<br><br>`upper('tom')` → `TOM`|



|Function/Operator<br><br>Description<br><br>Example(s)|
|---|
|`text` `^@` `text` → `boolean`<br><br>Returns true if the first string starts with the second string (equivalent to the `starts_with()` function).<br><br>`'alphabet' ^@ 'alph'` → `t`|
|`ascii` ( `text` ) → `integer`<br><br>Returns the numeric code of the first character of the argument. In UTF8 encoding, returns the Unicode code point of the character. In other multibyte encodings, the argument must be an ASCII character.<br><br>`ascii('x')` → `120`|
|`chr` ( `integer` ) → `text`<br><br>Returns the character with the given code. In UTF8 encoding the argument is treated as a Unicode code point. In other multibyte encodings the argument must designate an ASCII character. `chr(0)` is disallowed because text data types cannot store that character.<br><br>`chr(65)` → `A`|
|`concat` ( _`val1`_ `"any"` [, _`val2`_ `"any"` [, ...] ] ) → `text`<br><br>Concatenates the text representations of all the arguments. NULL arguments are ignored.<br><br>`concat('abcde', 2, NULL, 22)` → `abcde222`|
|`concat_ws` ( _`sep`_ `text`, _`val1`_ `"any"` [, _`val2`_ `"any"` [, ...] ] ) → `text`<br><br>Concatenates all but the first argument, with separators. The first argument is used as the separator string, and should not be NULL. Other NULL arguments are ignored.<br><br>`concat_ws(',', 'abcde', 2, NULL, 22)` → `abcde,2,22`|
|`format` ( _`formatstr`_ `text` [, _`formatarg`_ `"any"` [, ...] ] ) → `text`<br><br>Formats arguments according to a format string; see [Section 9.4.1](https://www.postgresql.org/docs/current/functions-string.html#FUNCTIONS-STRING-FORMAT "9.4.1. format"). This function is similar to the C function `sprintf`.<br><br>`format('Hello %s, %1$s', 'World')` → `Hello World, World`|
|`initcap` ( `text` ) → `text`<br><br>Converts the first letter of each word to upper case and the rest to lower case. Words are sequences of alphanumeric characters separated by non-alphanumeric characters.<br><br>`initcap('hi THOMAS')` → `Hi Thomas`|
|`left` ( _`string`_ `text`, _`n`_ `integer` ) → `text`<br><br>Returns first _`n`_ characters in the string, or when _`n`_ is negative, returns all but last \|_`n`_\| characters.<br><br>`left('abcde', 2)` → `ab`|
|`length` ( `text` ) → `integer`<br><br>Returns the number of characters in the string.<br><br>`length('jose')` → `4`|
|`md5` ( `text` ) → `text`<br><br>Computes the MD5 [hash](https://www.postgresql.org/docs/current/functions-binarystring.html#FUNCTIONS-HASH-NOTE) of the argument, with the result written in hexadecimal.<br><br>`md5('abc')` → `900150983cd24fb0​d6963f7d28e17f72`|
|`parse_ident` ( _`qualified_identifier`_ `text` [, _`strict_mode`_ `boolean` `DEFAULT` `true` ] ) → `text[]`<br><br>Splits _`qualified_identifier`_ into an array of identifiers, removing any quoting of individual identifiers. By default, extra characters after the last identifier are considered an error; but if the second parameter is `false`, then such extra characters are ignored. (This behavior is useful for parsing names for objects like functions.) Note that this function does not truncate over-length identifiers. If you want truncation you can cast the result to `name[]`.<br><br>`parse_ident('"SomeSchema".someTable')` → `{SomeSchema,sometable}`|
|`pg_client_encoding` ( ) → `name`<br><br>Returns current client encoding name.<br><br>`pg_client_encoding()` → `UTF8`|
|`quote_ident` ( `text` ) → `text`<br><br>Returns the given string suitably quoted to be used as an identifier in an SQL statement string. Quotes are added only if necessary (i.e., if the string contains non-identifier characters or would be case-folded). Embedded quotes are properly doubled. See also [Example 43.1](https://www.postgresql.org/docs/current/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE "Example 43.1. Quoting Values in Dynamic Queries").<br><br>`quote_ident('Foo bar')` → `"Foo bar"`|
|`quote_literal` ( `text` ) → `text`<br><br>Returns the given string suitably quoted to be used as a string literal in an SQL statement string. Embedded single-quotes and backslashes are properly doubled. Note that `quote_literal` returns null on null input; if the argument might be null, `quote_nullable` is often more suitable. See also [Example 43.1](https://www.postgresql.org/docs/current/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE "Example 43.1. Quoting Values in Dynamic Queries").<br><br>`quote_literal(E'O\'Reilly')` → `'O''Reilly'`|
|`quote_literal` ( `anyelement` ) → `text`<br><br>Converts the given value to text and then quotes it as a literal. Embedded single-quotes and backslashes are properly doubled.<br><br>`quote_literal(42.5)` → `'42.5'`|
|`quote_nullable` ( `text` ) → `text`<br><br>Returns the given string suitably quoted to be used as a string literal in an SQL statement string; or, if the argument is null, returns `NULL`. Embedded single-quotes and backslashes are properly doubled. See also [Example 43.1](https://www.postgresql.org/docs/current/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE "Example 43.1. Quoting Values in Dynamic Queries").<br><br>`quote_nullable(NULL)` → `NULL`|
|`quote_nullable` ( `anyelement` ) → `text`<br><br>Converts the given value to text and then quotes it as a literal; or, if the argument is null, returns `NULL`. Embedded single-quotes and backslashes are properly doubled.<br><br>`quote_nullable(42.5)` → `'42.5'`|
|`regexp_count` ( _`string`_ `text`, _`pattern`_ `text` [, _`start`_ `integer` [, _`flags`_ `text` ] ] ) → `integer`<br><br>Returns the number of times the POSIX regular expression _`pattern`_ matches in the _`string`_; see [Section 9.7.3](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP "9.7.3. POSIX Regular Expressions").<br><br>`regexp_count('123456789012', '\d\d\d', 2)` → `3`|
|`regexp_instr` ( _`string`_ `text`, _`pattern`_ `text` [, _`start`_ `integer` [, _`N`_ `integer` [, _`endoption`_ `integer` [, _`flags`_ `text` [, _`subexpr`_ `integer` ] ] ] ] ] ) → `integer`<br><br>Returns the position within _`string`_ where the _`N`_'th match of the POSIX regular expression _`pattern`_ occurs, or zero if there is no such match; see [Section 9.7.3](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP "9.7.3. POSIX Regular Expressions").<br><br>`regexp_instr('ABCDEF', 'c(.)(..)', 1, 1, 0, 'i')` → `3`<br><br>`regexp_instr('ABCDEF', 'c(.)(..)', 1, 1, 0, 'i', 2)` → `5`|
|`regexp_like` ( _`string`_ `text`, _`pattern`_ `text` [, _`flags`_ `text` ] ) → `boolean`<br><br>Checks whether a match of the POSIX regular expression _`pattern`_ occurs within _`string`_; see [Section 9.7.3](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP "9.7.3. POSIX Regular Expressions").<br><br>`regexp_like('Hello World', 'world$', 'i')` → `t`|
|`regexp_match` ( _`string`_ `text`, _`pattern`_ `text` [, _`flags`_ `text` ] ) → `text[]`<br><br>Returns substrings within the first match of the POSIX regular expression _`pattern`_ to the _`string`_; see [Section 9.7.3](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP "9.7.3. POSIX Regular Expressions").<br><br>`regexp_match('foobarbequebaz', '(bar)(beque)')` → `{bar,beque}`|
|`regexp_matches` ( _`string`_ `text`, _`pattern`_ `text` [, _`flags`_ `text` ] ) → `setof text[]`<br><br>Returns substrings within the first match of the POSIX regular expression _`pattern`_ to the _`string`_, or substrings within all such matches if the `g` flag is used; see [Section 9.7.3](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP "9.7.3. POSIX Regular Expressions").<br><br>`regexp_matches('foobarbequebaz', 'ba.', 'g')` →<br><br> {bar}<br> {baz}|
|`regexp_replace` ( _`string`_ `text`, _`pattern`_ `text`, _`replacement`_ `text` [, _`start`_ `integer` ] [, _`flags`_ `text` ] ) → `text`<br><br>Replaces the substring that is the first match to the POSIX regular expression _`pattern`_, or all such matches if the `g` flag is used; see [Section 9.7.3](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP "9.7.3. POSIX Regular Expressions").<br><br>`regexp_replace('Thomas', '.[mN]a.', 'M')` → `ThM`|
|`regexp_replace` ( _`string`_ `text`, _`pattern`_ `text`, _`replacement`_ `text`, _`start`_ `integer`, _`N`_ `integer` [, _`flags`_ `text` ] ) → `text`<br><br>Replaces the substring that is the _`N`_'th match to the POSIX regular expression _`pattern`_, or all such matches if _`N`_ is zero; see [Section 9.7.3](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP "9.7.3. POSIX Regular Expressions").<br><br>`regexp_replace('Thomas', '.', 'X', 3, 2)` → `ThoXas`|
|`regexp_split_to_array` ( _`string`_ `text`, _`pattern`_ `text` [, _`flags`_ `text` ] ) → `text[]`<br><br>Splits _`string`_ using a POSIX regular expression as the delimiter, producing an array of results; see [Section 9.7.3](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP "9.7.3. POSIX Regular Expressions").<br><br>`regexp_split_to_array('hello world', '\s+')` → `{hello,world}`|
|`regexp_split_to_table` ( _`string`_ `text`, _`pattern`_ `text` [, _`flags`_ `text` ] ) → `setof text`<br><br>Splits _`string`_ using a POSIX regular expression as the delimiter, producing a set of results; see [Section 9.7.3](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP "9.7.3. POSIX Regular Expressions").<br><br>`regexp_split_to_table('hello world', '\s+')` →<br><br> hello<br> world|
|`regexp_substr` ( _`string`_ `text`, _`pattern`_ `text` [, _`start`_ `integer` [, _`N`_ `integer` [, _`flags`_ `text` [, _`subexpr`_ `integer` ] ] ] ] ) → `text`<br><br>Returns the substring within _`string`_ that matches the _`N`_'th occurrence of the POSIX regular expression _`pattern`_, or `NULL` if there is no such match; see [Section 9.7.3](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP "9.7.3. POSIX Regular Expressions").<br><br>`regexp_substr('ABCDEF', 'c(.)(..)', 1, 1, 'i')` → `CDEF`<br><br>`regexp_substr('ABCDEF', 'c(.)(..)', 1, 1, 'i', 2)` → `EF`|
|`repeat` ( _`string`_ `text`, _`number`_ `integer` ) → `text`<br><br>Repeats _`string`_ the specified _`number`_ of times.<br><br>`repeat('Pg', 4)` → `PgPgPgPg`|
|`replace` ( _`string`_ `text`, _`from`_ `text`, _`to`_ `text` ) → `text`<br><br>Replaces all occurrences in _`string`_ of substring _`from`_ with substring _`to`_.<br><br>`replace('abcdefabcdef', 'cd', 'XX')` → `abXXefabXXef`|
|`reverse` ( `text` ) → `text`<br><br>Reverses the order of the characters in the string.<br><br>`reverse('abcde')` → `edcba`|
|`right` ( _`string`_ `text`, _`n`_ `integer` ) → `text`<br><br>Returns last _`n`_ characters in the string, or when _`n`_ is negative, returns all but first \|_`n`_\| characters.<br><br>`right('abcde', 2)` → `de`|
|`split_part` ( _`string`_ `text`, _`delimiter`_ `text`, _`n`_ `integer` ) → `text`<br><br>Splits _`string`_ at occurrences of _`delimiter`_ and returns the _`n`_'th field (counting from one), or when _`n`_ is negative, returns the \|_`n`_\|'th-from-last field.<br><br>`split_part('abc~@~def~@~ghi', '~@~', 2)` → `def`<br><br>`split_part('abc,def,ghi,jkl', ',', -2)` → `ghi`|
|`starts_with` ( _`string`_ `text`, _`prefix`_ `text` ) → `boolean`<br><br>Returns true if _`string`_ starts with _`prefix`_.<br><br>`starts_with('alphabet', 'alph')` → `t`|
|`string_to_array` ( _`string`_ `text`, _`delimiter`_ `text` [, _`null_string`_ `text` ] ) → `text[]`<br><br>Splits the _`string`_ at occurrences of _`delimiter`_ and forms the resulting fields into a `text` array. If _`delimiter`_ is `NULL`, each character in the _`string`_ will become a separate element in the array. If _`delimiter`_ is an empty string, then the _`string`_ is treated as a single field. If _`null_string`_ is supplied and is not `NULL`, fields matching that string are replaced by `NULL`. See also [`array_to_string`](https://www.postgresql.org/docs/current/functions-array.html#FUNCTION-ARRAY-TO-STRING).<br><br>`string_to_array('xx~~yy~~zz', '~~', 'yy')` → `{xx,NULL,zz}`|
|`string_to_table` ( _`string`_ `text`, _`delimiter`_ `text` [, _`null_string`_ `text` ] ) → `setof text`<br><br>Splits the _`string`_ at occurrences of _`delimiter`_ and returns the resulting fields as a set of `text` rows. If _`delimiter`_ is `NULL`, each character in the _`string`_ will become a separate row of the result. If _`delimiter`_ is an empty string, then the _`string`_ is treated as a single field. If _`null_string`_ is supplied and is not `NULL`, fields matching that string are replaced by `NULL`.<br><br>`string_to_table('xx~^~yy~^~zz', '~^~', 'yy')` →<br><br> xx<br> NULL<br> zz|
|`strpos` ( _`string`_ `text`, _`substring`_ `text` ) → `integer`<br><br>Returns first starting index of the specified _`substring`_ within _`string`_, or zero if it's not present. (Same as ``position(_`substring`_ in _`string`_)``, but note the reversed argument order.)<br><br>`strpos('high', 'ig')` → `2`|
|`substr` ( _`string`_ `text`, _`start`_ `integer` [, _`count`_ `integer` ] ) → `text`<br><br>Extracts the substring of _`string`_ starting at the _`start`_'th character, and extending for _`count`_ characters if that is specified. (Same as ``substring(_`string`_ from _`start`_ for _`count`_)``.)<br><br>`substr('alphabet', 3)` → `phabet`<br><br>`substr('alphabet', 3, 2)` → `ph`|
|`to_ascii` ( _`string`_ `text` ) → `text`<br><br>`to_ascii` ( _`string`_ `text`, _`encoding`_ `name` ) → `text`<br><br>`to_ascii` ( _`string`_ `text`, _`encoding`_ `integer` ) → `text`<br><br>Converts _`string`_ to ASCII from another encoding, which may be identified by name or number. If _`encoding`_ is omitted the database encoding is assumed (which in practice is the only useful case). The conversion consists primarily of dropping accents. Conversion is only supported from `LATIN1`, `LATIN2`, `LATIN9`, and `WIN1250` encodings. (See the [unaccent](https://www.postgresql.org/docs/current/unaccent.html "F.48. unaccent — a text search dictionary which removes diacritics") module for another, more flexible solution.)<br><br>`to_ascii('Karél')` → `Karel`|
|`to_hex` ( `integer` ) → `text`<br><br>`to_hex` ( `bigint` ) → `text`<br><br>Converts the number to its equivalent hexadecimal representation.<br><br>`to_hex(2147483647)` → `7fffffff`|
|`translate` ( _`string`_ `text`, _`from`_ `text`, _`to`_ `text` ) → `text`<br><br>Replaces each character in _`string`_ that matches a character in the _`from`_ set with the corresponding character in the _`to`_ set. If _`from`_ is longer than _`to`_, occurrences of the extra characters in _`from`_ are deleted.<br><br>`translate('12345', '143', 'ax')` → `a2x5`|
|`unistr` ( `text` ) → `text`<br><br>Evaluate escaped Unicode characters in the argument. Unicode characters can be specified as ``\_`XXXX`_`` (4 hexadecimal digits), ``\+_`XXXXXX`_`` (6 hexadecimal digits), ``\u_`XXXX`_`` (4 hexadecimal digits), or ``\U_`XXXXXXXX`_`` (8 hexadecimal digits). To specify a backslash, write two backslashes. All other characters are taken literally.<br><br>If the server encoding is not UTF-8, the Unicode code point identified by one of these escape sequences is converted to the actual server encoding; an error is reported if that's not possible.<br><br>This function provides a (non-standard) alternative to string constants with Unicode escapes (see [Section 4.1.2.3](https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS-UESCAPE "4.1.2.3. String Constants with Unicode Escapes")).<br><br>`unistr('d\0061t\+000061')` → `data`<br><br>`unistr('d\u0061t\U00000061')` → `data`|



format(formatstr text [, formatarg "any" [, ...] ])